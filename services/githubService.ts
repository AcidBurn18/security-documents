import { Octokit } from "@octokit/rest";
import { GitHubConfig, SecurityControl, PRStatus } from "../types";

// Helper to generate Markdown content
const generateMarkdown = (serviceName: string, controls: SecurityControl[]) => {
  return `# Security Controls: ${serviceName}

| ID | Name | Description | Plane | Mapping |
|----|------|-------------|-------|---------|
${controls.map(c => `| ${c.controlId} | ${c.controlName} | ${c.controlDescription} | ${c.plane} | ${c.mapping} |`).join('\n')}

*Generated by CloudGuard Gen*
`;
};

export const pushToGitHub = async (
  config: GitHubConfig, 
  serviceName: string, 
  controls: SecurityControl[]
) => {
  const octokit = new Octokit({ auth: config.token });
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const branchName = `security-controls/${serviceName.replace(/\s+/g, '-').toLowerCase()}-${timestamp}`;
  const fileName = `controls/${serviceName.replace(/\s+/g, '_')}_controls.md`;

  try {
    // 1. Get Reference to base branch
    let baseSha: string;
    let usedBaseBranch = config.branchBase;

    try {
      const { data: refData } = await octokit.git.getRef({
        owner: config.owner,
        repo: config.repo,
        ref: `heads/${config.branchBase}`,
      });
      baseSha = refData.object.sha;
    } catch (error: any) {
      if (error.status === 404 && config.branchBase === 'main') {
        try {
          const { data: refDataMaster } = await octokit.git.getRef({
            owner: config.owner,
            repo: config.repo,
            ref: `heads/master`,
          });
          baseSha = refDataMaster.object.sha;
          usedBaseBranch = 'master';
        } catch (innerError: any) {
           throw new Error(`Could not find base branch 'main' or 'master' in repository '${config.owner}/${config.repo}'. Please check the repository URL.`);
        }
      } else if (error.status === 403) {
         throw new Error(`Permission denied accessing repository. Please ensure your Token has 'repo' scope.`);
      } else {
        throw error;
      }
    }

    // 2. Create new Branch
    await octokit.git.createRef({
      owner: config.owner,
      repo: config.repo,
      ref: `refs/heads/${branchName}`,
      sha: baseSha,
    });

    // 3. Create Markdown Content
    const mdContent = generateMarkdown(serviceName, controls);
    const contentEncoded = btoa(unescape(encodeURIComponent(mdContent)));

    await octokit.repos.createOrUpdateFileContents({
      owner: config.owner,
      repo: config.repo,
      path: fileName,
      message: `Add security controls for ${serviceName}`,
      content: contentEncoded,
      branch: branchName,
    });

    // 5. Create Pull Request
    const { data: prData } = await octokit.pulls.create({
      owner: config.owner,
      repo: config.repo,
      title: `Security Controls: ${serviceName}`,
      head: branchName,
      base: usedBaseBranch,
      body: `Automated PR containing security controls for **${serviceName}**.\n\nPlease review against organizational standards.`,
    });

    // 6. Request Reviewers
    if (config.reviewers && config.reviewers.trim()) {
      const reviewers = config.reviewers.split(',').map(r => r.trim()).filter(r => r.length > 0);
      if (reviewers.length > 0) {
        try {
          await octokit.pulls.requestReviewers({
            owner: config.owner,
            repo: config.repo,
            pull_number: prData.number,
            reviewers: reviewers,
          });
        } catch (reviewError) {
          console.warn("Failed to add reviewers (PR still created):", reviewError);
        }
      }
    }

    return {
      html_url: prData.html_url,
      number: prData.number,
      branch: branchName,
      owner: config.owner,
      repo: config.repo
    };

  } catch (error: any) {
    console.error("GitHub Operation failed:", error);
    if (error.status === 403) {
        if (error.message.includes('Resource not accessible by personal access token')) {
            throw new Error("Token Permission Error: Fine-grained tokens require 'Contents: Read & Write' and 'Pull Requests: Read & Write'. Classic tokens require 'repo' scope.");
        }
        throw new Error("Permission Denied: Check that your token has write access to this repository.");
    }
    throw error;
  }
};

export const updateExistingBranch = async (
  config: GitHubConfig,
  serviceName: string,
  branchName: string,
  controls: SecurityControl[]
) => {
  const octokit = new Octokit({ auth: config.token });
  const fileName = `controls/${serviceName.replace(/\s+/g, '_')}_controls.md`;
  
  // Get current file sha
  const { data: fileData } = await octokit.repos.getContent({
    owner: config.owner,
    repo: config.repo,
    path: fileName,
    ref: branchName
  }) as any;

  const mdContent = generateMarkdown(serviceName, controls);
  const contentEncoded = btoa(unescape(encodeURIComponent(mdContent)));

  await octokit.repos.createOrUpdateFileContents({
    owner: config.owner,
    repo: config.repo,
    path: fileName,
    message: `Update security controls for ${serviceName} based on feedback`,
    content: contentEncoded,
    branch: branchName,
    sha: fileData.sha
  });
};

export const getPRDetails = async (config: GitHubConfig, prNumber: number) => {
  const octokit = new Octokit({ auth: config.token });
  
  const { data: pr } = await octokit.pulls.get({
    owner: config.owner,
    repo: config.repo,
    pull_number: prNumber
  });

  let status = PRStatus.OPEN;
  if (pr.merged) status = PRStatus.MERGED;
  else if (pr.state === 'closed') status = PRStatus.CLOSED;

  // Get comments if open or closed (for feedback)
  const { data: comments } = await octokit.issues.listComments({
    owner: config.owner,
    repo: config.repo,
    issue_number: prNumber
  });
  
  // Also get review comments (inline code comments)
  const { data: reviews } = await octokit.pulls.listReviews({
    owner: config.owner,
    repo: config.repo,
    pull_number: prNumber
  });

  const feedback = [
    ...comments.map(c => `User ${c.user?.login}: ${c.body}`),
    ...reviews.map(r => `Reviewer ${r.user?.login} (${r.state}): ${r.body}`)
  ].join('\n---\n');

  return { status, feedback, merged: pr.merged };
};
